# JS之路
## JS是?
```
1 Javasript是轻量级的脚本语言。
2 什么是脚本语言。脚本语言不具备开发操作系统的能力，只能编写控制大型应用程序（Browser）的脚本。
3 javasript本身的语法相对简单，且也是一种嵌入式语言。它通常是嵌入到某个特定的宿主环境中以借用
宿主提供的API,去完成更多复杂的功能。
4 js常见的宿主环境：浏览器 / 服务器（node环境中）
```
## JS脚本通用成分归纳

### 语句和表达式
```
1 语句:通常一个语句以分号作为结束标识。语句,是（为了完成某）个（任务进行的）操作，没有返回值。
2 表达式:表达式具有返回值。是一个为了得到值的计算式。
3 区别和联系:通常表达式只是语句的一部分，但是不是说语句中一定有表达式。表达式是语句的可选成分。
```
### 变量
```
1 变量和变量名:变量是对值的具名应用,变量名是值的容器和只带，方便值的使用。js的变量名区分大小写。
2 声明和赋值:
  i) var a = 1. 其中声明变量使用了关键字 var; 赋值使用了 1; var a = undefined === var a;
  "undefined"是一个特殊的值,它的含义是默认/缺省值,即没给值时的值。
  ii) not defined 和 undefined.直接使用一个从未声明的变量会提示'xx is not defined';
  使用一个声明了没有赋值的变量会提示 'xx is undefined',存在变量提升【var 特有】。可以理解为声明的时候一定会赋值,
  只不过是隐式地赋值为undefined还是有意义的值。
  iii) var 声明限制宽松,运行重复声明（赋值）同名变量【var特有】。这与es6 的let 与 const 不同。
  iv) 变量提升:这和js引擎工作方式有关,它会在解析代码时,先取得所有变量的声明,然后再逐行执行。
```
### 标识符
```
  1 标识符只能由[数字][字母][_][$][unicode字符] 组成且组成变量或函数等的标识符的首字母不能是数字。
  2 var 成功 = 23;//这是允许的,因为中文是unicode字符的一部分。
  3 unicode编码又叫万国码,统一码,它包含了ASII码。
  4 js的保留关键字不能用作标识符。（最高级）

  小结:标识符不能是保留关键词。
       标识符是数字字母下划线美元符和unicode字符的排列组合，但是还要求首字符不能是数字。
```
### 注释
 ``` 注释的意义:告知js引擎忽略此部分代码。具有屏蔽和解析两种使用场景
     一 通用分类:单行注释（// + <!--html代码-->） +  多行注释 （/**/） 
     二 使用场景分类:html注释（<!--html代码-->） + css或js注释（通用的/*css代码或js代码*/）
 ```

 ### 区块和块级作用域和函数作用域
 ```
 将多个操作（语句）组合在一起以完成更复杂或着通用的功能时使用 
 {

 }
 如 函数 function f(){//函数作用域
    //函数体
 }
 如 for(){//let 声明形成块级作用域
    //循环体
 }
 如 if(){//let 声明形成块级作用域
    //条件体
 }

js实例：

{
 var a = 12
}
console.log(a);//12
if(false){
   var b = 12;
}
console.log(b);//undefined

//原因是var声明存在变量提升
var a;
{
    a = 12
};
console.log(a)

小结:独立的单独的区块没有什么特别的作用,配合函数声明和let 声明可以组合成特有的 “函数作用域”和 “块级作用域”。
循环体和条件体不能隔绝var 变量的提升,函数可以。所以作用域才会有“函数作用域”而没有所谓的条件作用域和循环作用域。
函数体会阻止var 声明的变量提升,循环体和条件体则无法阻止。

函数作用域 = 区块 {} + function 声明
块级作用域 = 区块 {} + let 声明
函数作用域或块级作用域的只在函数内部或区块内部可见。（作用域链）
区块只有配合函数关键字function 或 let 形成了特有的作用域才能实现变量隔离。
 ```

 ### 条件语句
```
条件语句的构成要素：1 条件关键字 2 条件表达式 3 区块、条件体
  1)if 条件体
    实例：if(2=='2'){console.log('in')};条件表达式支持的运算符 "==" 或 "==="   
  2)if(){}else{} 条件体。
  3)switch(值1){case 值2:;break;} 值1 === 值2 case内的语句才会执行(隐式条件表达式全等比价)。
    实例：switch(2){case '2': console.log('in')  ;break;}; switch 条件表达式只支持全等运算符 '==='  
  4)三元条件体,可以看做是if..else的语法糖。
  ```
 ### 循环语句
 循环语句的构成要素：1 循环关键字 2 循环表达式 3 初始变量 4 自增变量 5 区块、循环体
 ```
  1)while 条件体
  2)do...while..
  3)for 条件体
 ```

 ### break 与 continue的使用场景
```
 一 break 语句
 1 break 用于switch 条件语句,跳出条件体
 2 break 用于单层循环中跳出循环条件体
 3 break 用于多重循环中跳出内层或外层的循环,取决于break直接存在于哪个循环的循环体中(独立使用break)
 4 break 用于多重循环中可以显式地指定要跳出的循环条件体(配合标签)
 小结:break用于跳出循环或者switch条件,多重循环中终止的循环取决于它在哪一层循环的循环体中。
      break终止其所在循环体中的循环。

 二 continue语句
 1 跳出本次循环,进入循环头部开始下次循环。一轮循环 ==  n次循环
```
### 标签（和语句强关联）
```
使用方式 "标签标识符 + ':' +语句！！！！！"。
使用场景: 通常和break或continue在循环语句搭配使用，显式地终止或中断循环。
命名规则：标签的命名遵循标识符的规则

1 语句（条件语句/循环语句...）前面可以使用标签。
2 语句是一个或多个操作的聚合体。
2 标签可以用来跳出结构体。
  i)显示跳出循环体。
  ii)跳出普通代码块。

//跳出循环示例(类推continue):
test:for(){
  for(){
    break test;//此时直接终止了整个嵌套的循环
  }
}
//跳出区块(代码块)实例:
test:{
  let a = 12;
  console.log(a);
  break test;//后续不执行(函数中有专有阻断return)
  let b = 24;
  console.log(b);
}
//跳出条件语句
let a = 23
test:if(a > 20 ){
  console.log(a);
  break test;
  let b = 25;
  console.log(b);
}  
```
## JS语法明细(ECMAScript + DOM + BOM)
### 数据类型
```
1 数据类型不能脱离值来讨论，可以看做是值的固有属性。可以放在等号右侧作为表达式（即:值）使用的都看作数据类型。
2 数据类型分两大类。有不同的说法，但是核心点在于一个名字是否对应一个值。
  i) 名值一一对应则归为简单数据类型(原始数据类型)。
  ii) 名值一对多则归为复合数据类型（应用数据类型、合成数据类型）
  iii) 简单数据类型储存在栈内存，存放的值本身。
  iv) 复合数据类型的地址存在栈内存,堆内存中存放的是值的集合。

3 数据类型可以细分为 undefined null object 布尔 数值 字符串（undefined null 对象 是不是 数值 字符串）  
  1)null / undefined 是值为null/undefined 的数据类型，null类型只有一个值null,undefined类型只有一个值undefined.
  2)null值的含义: null "空对象,空引用"; undefined值表示'默认值,缺省值,声明但是未显式地赋值'.
  3)广义的对象 = 狭义的对象(object) + function + array .

4 数据类型判断:typeof(val) 
  i) val 是基本数据类型的值，返回对应基本数据类型名称.
  ii) val 是 null 返回object,val是undefined 返回undefined.
  iii) val是 object 返回object,val是function 返回function,val 是array 返回object.
  iv) val 没有声明或者没有赋值时都返回undefined

  小结:数据类型返回值是object除了object 还有 null array类型.
```
#### null 与 undefined
```
null 表示"空值,空对象,空引用"，需要显式地进行赋值使用。参与数值运算时会为转换为0,参与逻辑运算时或被转换为false
1) 0  【数值关联】
2) false 【布尔值关联】
3) 程序正常,无异常抛出。
----------------
undefined 表示"未定义的",它更像是一种隐式的语法现象的代名词。通常是不规返的或默认的兜底操作。参与数值运算时转换为NaN,参与逻辑运算时转换为false.

##非常规操作
1)变量声明了但是未赋值。 let a ; console.log(a)
2)直接访问对象中未定义的属性 let obj = {name:"test"};console.log(obj.age);
3)直接判断一个未声明过的变量。 typeof(tt); "直接使用未声明的变量是会报错的。 console.log(tt) tt is not defined"
4)函数没有返回值时。function test(){} test();
5)函数体中使用了未赋值的形参。function test2(x){ consoel.log(x)} test2(); 类似1
##非常规操作

4)NaN 【数值关联:特殊的数值】 参与数值运算的操作数有一个是NaN(不是一个数值的number类型)则结果一定是NaN.
5)false 【布尔值关联】
```
小结:主动将一个变量声明为undefined是没有意义的,undefined表示的是'非常规、默认兜底操作'，显式地赋值为null才有意义。
表示'空值,空对象或空应用...'

#### 对象
#### 布尔值
```
以下值参与逻辑运算时会被转换成false,其它被转换成true
1 undefined
2 null
3 '' 或者 ""
4 0
5 NaN
```

#### 数值
```
  1 数值类型 = 整数 + 浮点数 + 特殊的数值([+/-]0/[+/-]infinity/NaN).
  2 JS中的数值:64位浮点数.
   1)在js内部,所有数字都是用小数（64位浮点数)来表示的,这决定了小数在参与运算时存在不精确的问题。
   （浮点数:存在有效位数,超出允行的精确位数时,存在误差）0.1+0.2 == 0.3 //false 
   2)浮点数的定义:小数点位置不固定的小数。如8.25 = 8.25* 10^0;8.25 = 82.5 * 10^-1.
   3)通用的浮点数表示数值的形式：value = (-1)^S * (v) * [进制数]^(指数位)
   4)js中的数字是由64位浮点数来表示的，结合t通用的浮点数表示数值的方式=》js中的数值由64位的(二)进制浮点数来表示。
   ###
   5)js中64位二进制的浮点数表示数值的方式:value = (-1)^S * 1.xx...xxx[V] * 2^(P).
     S:符号位【1】占1个位值,值:0/1.值的个数：2^1 =2  
     V:有效数字【13,64】(精确)占52个位置。有效位数是53位。有效位53意味着[2^-53,2^53]之间的整数都可以准确表示。
       js能够准确地表示15位的十进制数(有效位数的最大值是2^53,有16位十进制数,前15位是精确的)。
       
     P:指数位【2,12】占11个位置。正常情况，指数的值:0~2047 值的个数: 2^11 = 2048,
     其中V与P存在一项规定:IEEE 754规定,如果指数位的值是(0,2047)开区间,有效数字的第一位总是1且不保存到64位二进制浮点数中，
     这是有效位占位52,有效数字却占53位的原因。

    数值 = SV * VV * PV (符号位值*有效数字位值*指数位值)

  6)特殊的数值和关联运算
  ---------------------
    i)特殊的0值
    +0和-0 的唯一区别是,在js中,分母可以是0,这和数学是相悖的.分子是非零数时,分母是+0返回 +infinity;分母是-0,返回的值是-infinity
      1（NaN或者0）/0 >> NaN;
      2 非零数(除1)/0 >> Infinity
   ----------------------   
    ii) 特殊的NaN
     一 产生的场景
      1 字符串解析成数值时,出错
         6+ 'a' 
      2 脱离数学运行范畴时。
        Math.sqrt(-2) //参数只能是正数
        0/0 //分母不能为0 
     二 参与运算
       1 数值运算:NaN与任何数只能得到NaN.
       2 逻辑运算:NaN===NaN//false 或被看做false

   ---------------------- 
    iii)特殊的Infinity
     一 产生的场景
      1 大于等于2^1024会得到infinity(有数学意义的)
      2 分母为0,分子不为0或不为NaN(无数学意义)

      二 参与运算
      1 数值运算:满足常规数学思维
        以下特例：
        0 * infinity = NaN; 
        infinitiy/0 = infinity;
        infinity - infinity = NaN;
        infinity / infinity = NaN;
        
               
         
      2 逻辑运算 infinity === infinity //true ,无穷和NaN比较总是返回false
    
    7 数值的方法

      1 parseInt(args,[2,36])
        参数列表:args字符串参数否则先转换为字符串,[2,36] 进制数。第二个参数不是这个范围的数会被忽略，使用默认的10 
        含义:无第二个参数的默认含义是将"十进制的字符串参数args转换为十进制的整数",转换成功得到一个整数,失败NaN.
        返回值:NaN或者整数.
        注意:args 只能是包含数值的非空串，且这个非空串必须要以数值开头。如果这个非空串的首字符不能转换成数值,返回NaN.

      2 parseFloat(args)  
        参数列表：args字符串参数，否则会先转换为字符串。
        含义:将字符串参数转换为浮点数。
        返回值:NaN 或者浮点数
        注意:只能转换包含数值的非空串，且这个非空字符串一定要以数值开头。如果这个非空字符串的首字符不能转换成数值，返回NaN.
      
      3 Number(args)
        参数列表：args字符串参数。
        含义:将字符串参数转换为数值，这个字符串参数可以是含义为空的字符串,也可以是有且只有数值构成。此两种情况返回相应的数值，
        否则返回NaN.
        返回值:NaN 或者数值

        注意:当字符串参数不是含义为空时,只能是纯数值字符串。

      4 isFinite(args)
        参数：args任意值
        含义：判断指定参数是不是InFinity。
        返回值：布尔值。


      5 isNaN(args)
        参数:args任意值
        含义：判断指定参数是不是NaN
        返回值：布尔值。


    小结：
    1）符号位的值决定了数值的正负;有效数字位决定数值的精度（15位十进制数）;指数位决定了数值的大小。
     数值有正负、精确度、大小三个固有属性。
    2）数值的范围。指数决定数值的大小,正常情况下指数位占11位二进制位 （2^11=2048) 0~2047,有效数字是1开头,53位二进制位,小数位52;
       数值有正有负,均分一下 负数:[-1023~0],正数(0,1024] 数值范围:(2^-1023,2^1024),有效数字占位53，有效数字不再是1开头，小数位52;
    3）正向和负向溢出: 
       大于等于2^1024,则正向，返回infinity,正向只看指数位。
       小于等于2^-1075,则负向,返回0 -1075 =  n.xxx (2^-52) * 2^(-1023) 负向看有效位和指数位。
    
    4)特殊数值
     undefined或NaN参与的四则运算一定返回NaN.与数学相悖时返回NaN.字符串不能解析为数值时返回NaN.
     分母为0时（与数学相悖），需要看具体情况，分子是0或NaN或undefined返回NaN,分子是其他值时，返回infinity
     infinity - infinity //NaN 
     0 * infinity //NaN (其余正常数值都是返回infinity)
     infinity/infinity //NaN 

     5)数值的方法 :parseInt,parseFloat,Number,isFinite,isNaN
```
#### 字符串
```
  一 字符串是什么？
     字符串是单/双引号包裹起来的0个或多个Unicode字符。
  二 字符串的特性
    1)字符串具有类数组的特性。具有长度属性,可使用索引访问字符串中的字符。但是它只具有数组的长度属性和可读性。
    手动更改长度或者字符串指定位置或删除，无法影响到原有字符串。
    2)字符串的转义字符"\"
      如果转义字符后面的字符在特殊字符集合中，它就有其特殊含义，如果转移字符后面不在特殊字符集合中,转义字符表示的
      含义是'输出原字符'。
      所以转移字符只有两种情况，一种是'特定含义',一种是'输出原字符'
    3)js的字符串中的字符都用Unicode字符表示。声明一个字符串变量可以使用字母量的形式，也可以使用unicode字符形式。
      var foo =12 === var f\u006F\u006F=12.
     历史原因导致，字符串的长度不总是等于它实际长度。它的长度可能不准确。
     历史原因：每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存，JavaScript 对 UTF-16 的支持是不完整的，
     完整的utf-16(2个字节[16位],4个字节[32])，只支持两个字节的UTF-16
    
    4)base64转码
      i)它的主要目的不是为了加密而是为了不出现特殊字符。它转码后只允许数值，字母和 +, / 64中字符。
      2)bta(vachar) 将acii编码值成base64编码值。如将不可见（不可打印的）acii值转换成base64编码的值。
      如果值是中文等非acii值会报错。
        atb(vachar) 将base64编码值转换成acii值。
```

### 运算符
  1)
### 辅助语法
### 标准库
### 异步操作
### DOM
### BOM
### 事件

## JS编程思想
### 面向对象编程







